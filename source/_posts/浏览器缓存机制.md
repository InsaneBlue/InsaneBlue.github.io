---
title: 浏览器缓存机制
date: 2018-05-14 11:26:55
tags: http
categories: http
---

# 浏览器缓存机制

## 前言

web缓存大致可以分为以下几个类型：数据库缓存、服务器缓存、浏览器缓存、web应用缓存。本文主要讨论的是服务器和浏览器两方面对于web资源（如图片、js文件、数据等等）的缓存策略和机制。

<!--more-->

## 缓存的作用

+ 减少网络带宽消耗：对于已缓存的文件，可以减少请求带宽甚至无需请求网络，可以有效的降低运营成本。

+ 降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，将一些静态资源放置在网络的多个节点，也可以起到均衡负载的作用。

+ 减少网络延迟，加快页面打开速度：缓存能在在不影响网站交互的前提下能够明显加快网站加载速度和页面打开速度。

## 缓存的类型

1. 数据库缓存

    Web应用，特别是关系比较复杂、数据库表繁多的应用，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时直接从内存缓存直接返回，提高响应效率。

2. 服务器缓存

    - 代理服务器缓存

      代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。

    - CDN缓存

      CDN（Content Delivery Networks）缓存，也叫网关缓存、反向代理缓存、内容分发网络。CDN缓存一般是由网站管理员自己部署，为了让网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。

3. 浏览器缓存 

    浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以立即从浏览器缓存中读取出来。

4. Web应用层缓存
    应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据、页面、图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少请求次数，提高响应效率。

## 浏览器缓存机制

### 几个缓存相关的概念

- 新鲜度（过期机制）

  也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的：
    1. 含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；
    2. 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度；

- 校验值（验证机制）

  服务器返回资源时会在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需要重新获取资源内容。

- 强缓存

  浏览器加载资源时，会对资源进行检查，若发现资源没有过期则直接从本地缓存中获取，不发送请求到服务器，不与服务器发生交互行为。

- 协商缓存

  浏览器加载资源时，若强缓存没有生效，浏览器就会发送请求到服务器，询问服务器此资源是否有变化。如果协商缓存生效，服务器会返回304告知浏览器可以直接使用缓存；如果协商缓存未生效，服务器会返回200并将最新的资源一起返回，浏览器就会使用最新的资源。

### 缓存过程

  {% asset_img cache-flow.png %}

+ （a）浏览器判断是否有缓存

  浏览器会在本地缓存文件中查找是否有可用的缓存文件，不同的浏览器缓存文件的地址也不相同

+ （b）缓存是否过期

  浏览器会根据响应头中包含的两个字段来判断该缓存是否已经过期
  + expires
  
    http1.0中的标准，表明过期时间，一般是服务器的时间。

  + Cache-Control

    http1.1中的标准，表明对缓存的控制，可以设置不同的值来执行不同的缓存策略。常用的属性值后面会详细解释。

  如果缓存被浏览器判断为未过期，那么会直接使用缓存，这种类型的缓存属于强缓存；

  如果缓存被浏览器判断为已过期，那么浏览器会向服务器发送请求，若服务器返回304 Not Modified，这种类型的缓存就属于协商缓存（弱缓存）。

+ （c）跟服务器协商是否使用缓存

  同时如果上一次的缓存中有Last-modified 和 Etag 字段，浏览器将在请求头中加入If-Modified-Since（对应于Last-modified）， 和If-None-Match（对应于Etag），让服务器判断该资源是否过期。
  
+ （d）协商缓存
  服务器会判断该资源是否过期，如果未过期则返回304，告知浏览器可以使用浏览器端的缓存，如果已经过期则会返回200状态码和新的资源，并且在响应头中加上新资源的缓存策略（如Cache-Control和Etag等等），以便对新资源进行合理的缓存。

## 缓存头字段

### Expired/Cache-Control

#### Expired

  Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，例如：

  ```
  Expires:Thu, 31 Dec 2016 23:55:55 GMT
  ```

  缺点：由于它是服务器返回的一个绝对时间，这样存在一个问题，如果服务器时间与客户端时间的不一致，或者用户修改客户端时间，就会导致浏览器判断缓存失效，重新请求该资源

#### Cache-Control

  在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。这两者的区别就是前者是绝对时间，而后者是相对时间。例如：

  ```
  Cache-Control: max-age=2592000
  ```
  
  可以设置的属性值如下：
  1. max-age: 指定设置缓存最大的有效时间，单位为秒（s）。max-age会覆盖掉Expires

  2. s-maxage: 只用于共享缓存，比如CDN缓存（s -> share）。与max-age 的区别是：max-age用于普通缓存，而s-maxage用于代理缓存。如果存在     s-maxage,则会覆盖max-age 和 Expires.

  3. public：指定响应可以在代理缓存中被缓存，并且在多用户间共享。默认是public。

  4. private: 响应只作为私有的缓存，不能放在代理缓存上，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。对一些用户信息敏感的资源，通常需要设置为private。

  5. no-cache: 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而是在使用缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。

  6. no-store: 绝对禁止缓存任何资源，也就是说每次用户请求资源时，都会向服务器发送一个请求，每次都会下载完整的资源。通常用于机密性资源。

  7. must-revalidate: 如果页面过期，则去服务器进行获取。

### Last Modified/Etag

#### Last Modified

  服务器告知客户端，资源最后一次被修改的时间，例如

  ```
  Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT
  ```

  http1.0推出的，指服务器文件的最后修改时间。浏览器会带上If-Modified-Since向服务器发送请求，与服务器文件修改时间Last-Modified做对比，如果时间不同，则获取数据返回200，否则返回304后调用浏览器本地硬盘的缓存。

  缺点：
  1. 如果服务端文件频繁修改保存，那么Last-Modified就会频繁更改，每次都会从服务端获取。
  2. 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。
  3. 如果某些文件会被定期生成，但有时内容并没有任何变化（仅仅改变了时间），但Last-Modified却改变了，导致没有最大限度的利用缓存。

#### Etag

  为了弥补Last Modified的缺点，http1.1推出Etag来更加精确的控制缓存，如：

  ```
  ETag: "5bf7f01a-5d6"
  ```

  ETag并不是文件的版本号，而是一串可以代表该文件唯一的字符串（通常为文件的md5或者一段hash值），当客户端发现和服务器约定的直接读取缓存的时间过了，就在请求中发送If-None-Match选项，值即为上次请求后响应头的ETag值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则响应304，客户端直接读取缓存，如果不相同，则响应200，并返回最新的数据，同时附带新的ETag值。
