---
title: 前端性能监控
date: 2019-01-28 23:17:33
tags: [前端工程化, javascript]
categories: [前端工程化, javascript]
---

使用 window.performance 提供了一组精确的数据，经过简单的计算就能得出一些网页性能数据。

<!--more-->

## 性能相关字段

首先来看两张图，表示各阶段的开始与结束对应的时间，其中一张来自[Navigation Timing Level 2](https://w3c.github.io/navigation-timing/) 的详细说明

{% asset_img p1.jpg %}
{% asset_img p2.svg %}

```javascript
// 获取 performance 数据
var performance = {  
    // memory 是非标准属性，只在 Chrome 有
    memory: {
        usedJSHeapSize:  16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize
        totalJSHeapSize: 35100000, // 可使用的内存
        jsHeapSizeLimit: 793000000 // 内存大小限制
    },
 
    // 表示出现在当前浏览上下文的 navigation 类型，比如获取某个资源所需要的重定向次数
    navigation: {
        redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来
        type: 0           // 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）
                          // 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面
                          // 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）
                          // 255 即 TYPE_UNDEFINED    非以上方式进入的页面
    },
 
    timing: {
        // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等
        navigationStart: 1441112691935,
 
        // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0
        unloadEventStart: 0,
 
        // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳
        unloadEventEnd: 0,
 
        // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0
        redirectStart: 0,
 
        // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0
        redirectEnd: 0,
 
        // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前
        fetchStart: 1441112692155,
 
        // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
        domainLookupStart: 1441112692155,
 
        // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
        domainLookupEnd: 1441112692155,
 
        // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等
        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间
        connectStart: 1441112692155,
 
        // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等
        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间
        // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过
        connectEnd: 1441112692155,
 
        // HTTPS 连接开始的时间，如果不是安全连接，则值为 0
        secureConnectionStart: 0,
 
        // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存
        // 连接错误重连时，这里显示的也是新建立连接的时间
        requestStart: 1441112692158,
 
        // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存
        responseStart: 1441112692686,
 
        // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存
        responseEnd: 1441112692687,
 
        // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件
        domLoading: 1441112692690,
 
        // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件
        // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源
        domInteractive: 1441112693093,
 
        // DOM 解析完成后，网页内资源加载开始的时间
        // 在 DOMContentLoaded 事件抛出前发生
        domContentLoadedEventStart: 1441112693093,
 
        // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）
        domContentLoadedEventEnd: 1441112693101,
 
        // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件
        domComplete: 1441112693214,
 
        // load 事件发送给文档，也即 load 回调函数开始执行的时间
        // 注意如果没有绑定 load 事件，值为 0
        loadEventStart: 1441112693214,
 
        // load 事件的回调函数执行完毕的时间
        loadEventEnd: 1441112693215
 
        // 字母顺序
        // connectEnd: 1441112692155,
        // connectStart: 1441112692155,
        // domComplete: 1441112693214,
        // domContentLoadedEventEnd: 1441112693101,
        // domContentLoadedEventStart: 1441112693093,
        // domInteractive: 1441112693093,
        // domLoading: 1441112692690,
        // domainLookupEnd: 1441112692155,
        // domainLookupStart: 1441112692155,
        // fetchStart: 1441112692155,
        // loadEventEnd: 1441112693215,
        // loadEventStart: 1441112693214,
        // navigationStart: 1441112691935,
        // redirectEnd: 0,
        // redirectStart: 0,
        // requestStart: 1441112692158,
        // responseEnd: 1441112692687,
        // responseStart: 1441112692686,
        // secureConnectionStart: 0,
        // unloadEventEnd: 0,
        // unloadEventStart: 0
    }
};
```
## 性能指标计算

根据 Performance 提供的各种时间戳，经过简单计算可以得到一系列的性能数据。注释中标注为重要的，是我个人认为比较关键比较重要的部分指标，针对不同情况重要指标可能会发生变化，要结合实际情况分析。

```javascript
// 计算加载时间
function getPerformanceTiming () {  
    var performance = window.performance;
    var t = performance.timing;
    var times = {};
 
    //【重要】整个页面加载完成的时间
    //【原因】这表示从进入页面开始到页面完全可用的时间长度
    times.loadPage = t.loadEventEnd - t.navigationStart;
 
    //【重要】解析 DOM 树结构的时间，不包括例如图片、css等其他资源的加载
    //【原因】区别于解析 document 的时间，这里主要指dom结构的时间，可以参考domContentLoaded事件的相关机制
    times.domReady = t.domContentLoadedEventEnd - t.domContentLoadedEventStart;

    //【重要】解析 document 的时间
    //【原因】这里主要指解析整个文档内容的时间，包括各种资源的下载和执行，但不包括onload事件执行的事件
    times.documentReady = t.domComplete - t.domLoading;
 
    //【重要】DNS 查询时间
    //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？
    // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)            
    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;
 
    //【重要】读取页面第一个字节的时间
    //【原因】这个指标表明用户从第一个网络请求被发起到从服务器接收到第一个字节前所花费的时间，即TTFB（Time To First Byte）
    // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte
    times.ttfb = t.responseStart - t.navigationStart;
 
    //【重要】整个请求的时间
    //【原因】表示从请求开始到请求结束的时间指标，跟网络状况、资源大小相关
    times.request = t.responseEnd - t.requestStart;
 
    // 执行 onload 回调函数的时间
    times.loadEvent = t.loadEventEnd - t.loadEventStart;
 
    // 重定向的时间
    times.redirect = t.redirectEnd - t.redirectStart;

    // DNS 缓存时间
    times.appcache = t.domainLookupStart - t.fetchStart;
 
    // 卸载页面的时间
    times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;
 
    // TCP 建立连接完成握手的时间
    times.connect = t.connectEnd - t.connectStart;
 
    return times;
}
```

## 资源加载相关字段

上面讲述的都是 Navigation Timing ，资源加载的相关数据就需要使用 Resource Timing 
使用 performance.getEntries()，performance.getEntriesByName()，performance.getEntriesByType() 可以获取资源加载的数据，具体的API使用可以参考MDN上的示例。
这里用 performance.getEntries() ，返回值是一个数组，包含页面上所有的http请求。字段的意义可以参照上文图片中黄色的 Resource Timing 部分。下面是取数组中的某一个元素的示例，也可以认为是某一个资源的时间数据。

重复的字段这里不再介绍，新增的字段有四个：
+ name
+ entryType
+ initiatorType
+ duration

关于entryType字段的详细说明我没有找到，MDN上也没有很详细的准确的说明，有兴趣的小伙伴可以单独研究

```javascript
var entry = {  
    // 资源名称，一般来说是资源的路径
    name: "http://cdn.alloyteam.com/wp-content/themes/alloyteam/style.css",

    /* 资源类型有如下几种：
        resource: 资源
        navigation/frame: 页面
        mark: performance.mark()
        measure: performance.measure()
        paint: 如果是这种类型，那么相应的name就是'first-paint'和'first-contentful-paint'两者的其中之一
    */
    entryType: "resource", 

    /*  请求类型有如下几种情况：
        如果是页面元素，那么就是元素的名称，例如script，link，img等等.
        如果是CSS资源, 那么就是"css".
        如果是XMLHttpRequest对象, 那么就是"xmlhttprequest".
        如果是PerformanceNavigationTiming 对象, 那么就是空字符串"".
    */
    initiatorType: "link", 

    // 加载时间
    duration: 18.13399999809917,
    redirectStart: 0,
    redirectEnd: 0,
    fetchStart: 424.57699999795295,
    domainLookupStart: 0,
    domainLookupEnd: 0,
    connectStart: 0,
    connectEnd: 0,
    secureConnectionStart: 0,
    requestStart: 0,
    responseStart: 0,
    responseEnd: 442.7109999960521,
    startTime: 424.57699999795295
};
```

使用以上字段可以针对加载慢的资源进行追踪上报，例如上报 duration 超过10秒的资源。同时可以分析和评估网站资源加载的情况，例如根据如下三个时间范围来评估资源加载的情况：

+ 0.1秒 : 0.1 秒是用户感知的最小粒度，在这个时间范围内完成的操作被认为是流畅没有延迟的
+ 1.0秒 : 1.0 秒内完成的响应认为不会干扰用户的思维流。尽管用户能感觉到延迟，但 0.1 秒 -1.0 秒内完成的操作并不需要给出明显 loading 提示
+ 10秒 : 达到 10 秒用户将无法保持注意力，很可能选择离开做其他事情

具体方案这里就不展示代码了。

## 上报

通过前面的各种api，数据的收集基本完成了，剩下的工作就是上报了。
性能监控是辅助功能，应该做到不阻塞页面加载，并且在不影响页面正常使用的时候进行数据的获取、分析和上报，所以代码执行时间和上报时机的选择很重要。
既然是要监控页面和资源的加载情况，那么就应该等待页面和资源完全加载完毕之后，再进行数据的获取，所以把获取工作放到window.onload事件之后：

```javascript
// 收集回调
var callback = function() {};

function bindEvent(timeout) {
    var oriOnload = window.onload;
    window.onload = function(e) {
        if(typeof oriOnload === 'function') oriOnload(e);
        if(window.requestIdleCallback) {
            window.requestIdleCallback(callback, {
                timeout: timeout
            })
        }else {
            setTimeout(callback, timeout);
        }
    }
}
```

这里使用了 window.requestIdleCallback，这个方法会在浏览器空闲时期依次调用函数， 这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟触发而且关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。参数timeout是浏览器调用 callback 的最后期限。
